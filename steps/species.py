# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ErcTvbPluginDialog
                                 A QGIS plugin
 ERC-TVB integrates ecological continuities in Avoid, Minimize, Mitigate sequence
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-08-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by INRAE
        email                : mathieu.chailloux@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic, QtWidgets
from qgis.PyQt.QtCore import Qt

from ..qgis_lib_mc.utils import CustomException
from ..qgis_lib_mc.abstract_model import DictItem, DictModel, AbstractConnector
from ..ui.species_dialog import SpeciesDialogItem, SpeciesDialog


class SpeciesItem(SpeciesDialogItem):

    FIELDS = [ SpeciesDialogItem.ID, SpeciesDialogItem.FULL_NAME ]

    def __init__(self, dialog_item, parent=None):
        self.updateFromDataItem(data_item)
        DictItem.__init__(dialog_item.dict,fields=self.FIELDS)
        
    def updateFromDataItem(self,data_item):
        self.is_vector = type(data_item) is VectorDataItem
        if self.is_vector:
            if data_item.getBurnMode():
                val = data_item.getBurnField()
            else:
                val = data_item.getBurnVal()
        else:
            val = None
        self.dict = { self.PATH : data_item.getLayerPath(),
            self.MODE : self.is_vector,
            self.VALUE : val,
            self.STATUS : False }
        self.computed = False
        self.data_item = data_item
        self.name = self.getBaseName()
        
    def getBaseName(self):
        layer_path = self.data_item.getLayerPath()
        if not layer_path:
            raise utils.CustomException("No layer specified for vector import")
        res = os.path.basename(layer_path)
        # if self.is_vector and self.data_item.getBurnMode():
            # res += "_" + str(self.data_item.getBurnField())
        return res
        
    # def getNField(self,n):
        # if n == self.PATH_IDX:
            # return self.item[self.PATH]
        # elif n == self.MODE_IDX:
            # return 'V' if self.is_vector else 'R'
        # elif n == self.VALUE_IDX:
            # return self.item.burn_val
        # elif n == self.STATUS_IDX
            # return self.computed

class SpeciesModel(DictModel):

    def __init__(self, parentModel):
        # self.item_fields = [ self.PATH, self.EXPRESSION, self.BURN_MODE, self.BURN_VAL,
            # self.ALL_TOUCH, self.BUFFER_MODE, self.BUFFER_EXPR ]
        super().__init__(self,ImportItem.FIELDS,feedback=parentModel.feedback)
        self.parentModel = parentModel
        
    def addItem(self,item):
        super().addItem(item)
        self.parentModel.addImport(item)
        
    def applyItemWithContext(self,item,context,feedback):
        input_path = itme.getLayerPath()
        input = qgsUtils.loadLayer(input_path)
        input_extent = input.extent()
        crs = input.crs().authid()
        resolution = 10
        out_type = Qgis.Int16
        out_nodata = -1
        out_path = self.getItemOutPath(item)
        if item.is_vector:
            selected = QgsProcessingUtils.generateTempFilename('selection.gpkg')
            all_touch = item.getAllTouch()
            if item.getBurnMode():
                burn_field = item.getBurnField()
                BioDispersal_algs.applyRasterizationFixAllTouch(
                    selected,out_path,input_extent,resolution,
                    field=burn_field,out_type=out_type,all_touch=all_touch,
                    context=context,feedback=feedback)
            else:
                burn_val = item.getBurnVal()
                BioDispersal_algs.applyRasterizationFixAllTouch(
                    selected,out_path,input_extent,resolution,
                    burn_val=burn_val,out_type=out_type,all_touch=all_touch,
                    context=context,feedback=feedback)
        else:
            reclassified = QgsProcessingUtils.generateTempFilename('reclassified.tif')
            qgsTreatments.applyReclassifyByTable(input,matrix,reclassified,
                out_type = out_type,boundaries_mode=2,nodata_missing=True,
                context=context,feedback=feedback)
            qgsTreatments.applyWarpReproject(reclassified,out_path,dst_crs=crs,
                extent=input_extent,extent_crs=crs,resolution=resolution,
                out_type=out_type,overwrite=True,context=context,feedback=feedback)
                
    # Returns absolute path of 'item' output layer
    def getItemOutPath(self,item):
        out_bname = item.getName() + ".tif"
        out_dir = self.parentModel.getImportsDir()
        return os.path.join(out_dir,out_bname)
    def getItemFromName(self,name):
        for i in self.items:
            if i.name == name:
                return i
        return None
        
    def getImportNames(self):
        return [i.getBaseName() for i in self.items]
        
    def flags(self, index):
        return Qt.ItemIsSelectable | Qt.ItemIsEnabled

class SpeciesConnector(AbstractConnector):

    def __init__(self,dlg,model):
        self.dlg = dlg
        self.feedback = dlg.feedback
        self.onlySelection = False
        self.importModel = ImportModel(self)
        super().__init__(model,self.dlg.importView,
                         None,self.dlg.importDelete)

    def connectComponents(self):
        super().connectComponents()
        self.dlg.importView.doubleClicked.connect(self.openImport)
        self.dlg.importVector.clicked.connect(self.openImportVectorNew)
        self.dlg.importRaster.clicked.connect(self.openImportRasterNew)
    
    def openImport(self,index):
        row = index.row()
        item = self.model.getNItem(row)
        self.feedback.pushDebugInfo("openImport item = " +str(item))
        if item.is_vector:
            data_item = self.openImportVector(item.data_item)
        else:
            data_item = self.openImportRaster(item.data_item)
        if data_item:
            item.updateFromDataItem(data_item)
            self.model.layoutChanged.emit()
        
    def openImportVectorNew(self,checked):
        data_item = self.openImportVector(None)
        if data_item:
            item = ImportItem(data_item)
            self.model.addItem(item)
            self.model.layoutChanged.emit()
        
    def openImportVector(self,data_item):
        vector_data_dlg = VectorDataDialog(data_item,self.dlg)
        data_item = vector_data_dlg.showDialog()
        return data_item
        
    def openImportRasterNew(self,checked):
        data_item = self.openImportRaster(None)
        if data_item:
            item = ImportItem(data_item)
            self.model.addItem(item)
            self.model.layoutChanged.emit()
            
    def openImportRaster(self,data_item):
        raster_data_dlg = RasterDataDialog(data_item,self.dlg,class_model=self.model.frictionModel)
        data_item = raster_data_dlg.showDialog()
        return data_item
        
