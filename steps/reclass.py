# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MitiConnect
                                 A QGIS plugin
 MitiConnect integrates ecological Connectivity in Mitigation Hierarchy
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-08-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by INRAE
        email                : mathieu.chailloux@inrae.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import sys

from qgis.PyQt.QtCore import Qt

from ..qgis_lib_mc.abstract_model import DictItem, DictModel, AbstractConnector

class ClassItem(DictItem):

    INIT_VAL = 'INIT_VAL'
    NEW_VAL = 'NEW_VAL'
    ORIGIN = 'ORIGIN'
    
    FIELDS = [ ORIGIN, INIT_VAL, NEW_VAL ]
    
    def __init__(self,dict,pluginModel=None,feedback=None):
        super().__init__(dict,feedback=feedback)
        
    def getInitVal(self):
        return self.dict[self.INIT_VAL]
    def getNewVal(self):
        return self.dict[self.NEW_VAL]
    def getOrigin(self):
        return self.dict[self.ORIGIN]
        
    def equals(self,other):
        return ((self.getOrigin() == other.getOrigin()) and (self.getInitVal() == other.getInitVal()))


class ClassModel(DictModel):

    def __init__(self, pluginModel):
        itemClass = getattr(sys.modules[__name__], ClassItem.__name__)
        super().__init__(itemClass,feedback=pluginModel.feedback)
        self.pluginModel = pluginModel
        
    def addRow(self,origin,initVal,newVal):
        d = { ClassItem.INIT_VAL : str(initVal),
              ClassItem.NEW_VAL : str(newVal),
              ClassItem.ORIGIN : origin }
        item = ClassItem(d,feedback=self.feedback)
        self.addItem(item)
        self.pluginModel.frictionModel.addRowFromClassItem(item)
        self.layoutChanged.emit()
        
    def addRowFromValues(self,origin,values):
        freeVals = self.pluginModel.frictionModel.getFreeVals(len(values))
        for initVal, newVal in zip(values,freeVals):
            self.addRow(origin,initVal,newVal)
        # self.layoutChanged.emit()
        
    def removeItemsWithOrigin(self,origin):
        self.items = [ i for i in self.items if i.dict[ClassItem.ORIGIN] != origin ]
        self.layoutChanged.emit()
        
    def getClassTable(self,name):
        table = {}
        for i in self.items:
            if i.getOrigin() == name:
                outVal = i.dict[self.idField]
                inVal = str(i.dict[self.IMPORT_VAL])
                table[inVal] = outVal
        return table
    def getClassDict(self,name):
        table = {}
        for i in self.items:
            if i.getOrigin() == name:
                outVal = i.dict[self.idField]
                inVal = str(i.dict[self.IMPORT_VAL])
                table[inVal] = outVal
        return table
        
    def renameOrigin(self,oldName,newName):
        for item in self.items:
            if item.dict[self.ORIGIN] == oldName:
                item.dict[self.IMPORT] = newName
        self.layoutChanged.emit()
        
    def updateFromScenario(self,scName,initVals,codes):       
        self.feedback.pushDebugInfo("updateFromScenario " + str(scName))
        self.feedback.pushDebugInfo("updateFromScenario " + str(initVals))
        self.feedback.pushDebugInfo("updateFromScenario " + str(codes))
        assert(len(initVals) == len(codes))
        # Remove reclass item with matching name
        self.items = [i for i in self.items if i.getOrigin() != scName]
        valuesToAdd = []
        for initVal, code in zip(initVals,codes):
            self.addRow(scName,initVal,code)
        self.layoutChanged.emit()
        
    def flags(self, index):
        baseFlags = Qt.ItemIsSelectable | Qt.ItemIsEnabled
        if index.column() in [2]:
            baseFlags = baseFlags | Qt.ItemIsEditable
        return baseFlags
        
        
    # FIELDS = [ INPUT, MODE, VALUE, STATUS ]
    def getHeaderString(self,col):
        h = [self.tr('Origin'),
            self.tr('Initial value'),
            self.tr('New value')]
        return h[col]
        
class ClassConnector(AbstractConnector):
    
    def __init__(self,dlg,classModel):
        self.dlg = dlg
        self.feedback = classModel.feedback
        super().__init__(classModel,self.dlg.classView)
        
    def connectComponents(self):
        super().connectComponents()
        print("connectComponents")
        # self.model.layoutChanged.connect(self.model.pluginModel.frictionModel.updateFromImports)
        # self.model.itemChanged.connect(self.model.pluginModel.frictionModel.updateFromImports)